<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>JCIP Atlas · Chapter 13 · Explicit Locks</title>
  <link rel="stylesheet" href="assets/styles.css" />
</head>
<body>
  <div class="topbar">
    <div class="container">
      <div class="topbar-inner">
        <div class="brand">
          <div class="logo" aria-hidden="true"></div>
          <div>
            <h1>JCIP Interactive Atlas</h1>
            <span class="subtitle">Deep, interactive engineering notes · no dependencies</span>
          </div>
        </div>

        <div class="search" role="search" aria-label="Search">
          <span style="opacity:.8">⌕</span>
          <input id="globalSearch" type="text" placeholder="Search chapters &amp; modules…" aria-label="Search"/>
          <kbd id="searchHint" title="Press / to focus">/</kbd>
        </div>

        <div class="nav">
          <a class="chip active" href="index.html"><span class="dot"></span>Home</a><a class="chip" href="cheatsheet.html"><span class="dot"></span>Cheat Sheet</a><a class="chip" href="glossary.html"><span class="dot"></span>Glossary</a><a class="chip" href="patterns.html"><span class="dot"></span>Patterns</a>
          <button class="btn" id="themeToggle" title="Toggle theme (experimental)">☼</button>
        </div>
      </div>
    </div>
  </div>

  
  <div class="hero">
    <div class="container">
      <div class="hero-grid">
        <div class="hero-card">
          <div class="hero-card-inner">
            <div class="kicker"><span class="pill accent">Chapter 13</span><span class="pill ">IV · Advanced Topics</span><span class="pill ">Interactive engineering notes</span></div>
            <div class="h-title">Explicit Locks</div>
            <div class="h-sub">
      <div class="h-sub">
        A high-signal, example-driven companion to <i>Java Concurrency in Practice</i>. Each chapter distills the <b>engineering model</b> (invariants, failure modes, and APIs) into interactive labs and “production rules”.
        <div style="margin-top:10px" class="note"><strong>Copyright note:</strong> This atlas is an original learning aid and does not reproduce the book’s text. It provides new explanations, simulations, and example code.</div>
      </div>
    </div>
            <div class="cta-row"><a class="btn " href="chapter-12-testing-concurrent-programs.html">← Prev</a><a class="btn primary" href="index.html#chapters">All chapters</a><a class="btn " href="chapter-14-building-custom-synchronizers.html">Next →</a></div>
          </div>
        </div>
        <div class="right-stack">
        <div class="stat">
          <div class="row">
            <div>
              <div class="label">Key lens</div>
              <div class="value">Safety + Liveness + Performance</div>
            </div>
            <div class="badge ok">mental model</div>
          </div>
          <div class="hint">Safety: preserve invariants. Liveness: avoid waiting cycles & starvation. Performance: reduce contention & overhead.</div>
        </div>
        
        <div class="stat">
          <div class="row">
            <div>
              <div class="label">Workflow</div>
              <div class="value">Read → Simulate → Apply</div>
            </div>
            <div class="badge warn">practice</div>
          </div>
          <div class="hint">Use the labs to build intuition, then port the patterns to Java using j.u.c primitives.</div>
        </div>
        </div>
      </div>
    </div>
  </div>

  <div class="section">
    <div class="container">
      <h2>Chapter content</h2>
      <p class="lead">Search on this page filters cards and labs. Press <b>/</b> to jump to search, <b>Esc</b> to clear.</p>
      <div class="grid cols-2">
    <div class="card" data-searchable="Explicit locks: more control than synchronized 
          ReentrantLock provides features intrinsic locks don’t: timed tryLock, interruptible lock acquisition, and optional fairness policies. But with power comes responsibility: you must unlock in">
      <div class="card-header">
        <h3>Explicit locks: more control than synchronized</h3>
        <span class="badge ok">advanced</span>
      </div>
      <div class="card-body">
        
          <p><span style="font-family:var(--mono)">ReentrantLock</span> provides features intrinsic locks don’t: timed tryLock, interruptible lock acquisition, and optional fairness policies. But with power comes responsibility: you must unlock in <b>finally</b> blocks and design condition waiting correctly.</p>
        
      </div>
      
    </div>
    

    <div class="card" data-searchable="Conditions: multiple wait sets, precise signaling ReentrantLock lock = new ReentrantLock();
Condition notEmpty = lock.newCondition();
Condition notFull  = lock.newCondition();

void put(E e) throws InterruptedException {
  lock.lock();
  try{
    whi">
      <div class="card-header">
        <h3>Conditions: multiple wait sets, precise signaling</h3>
        <span class="badge warn">conditions</span>
      </div>
      <div class="card-body">
        <div class="code"><code>ReentrantLock lock = new ReentrantLock();
Condition notEmpty = lock.newCondition();
Condition notFull  = lock.newCondition();

void put(E e) throws InterruptedException {
  lock.lock();
  try{
    while(isFull()) notFull.await();
    enqueue(e);
    notEmpty.signal();
  } finally { lock.unlock(); }
}
</code></div>
          <p>Conditions support multiple independent predicates (e.g., notEmpty vs notFull), which can reduce spurious wakeups and improve clarity.</p>
        
      </div>
      
    </div>
    

    <div class="card" data-searchable="Fairness: throughput vs tail latency 
          Fair locks reduce starvation risk but can lower throughput by increasing context switches and reducing batching. Choose fairness when predictability matters more than raw throughput.
      ">
      <div class="card-header">
        <h3>Fairness: throughput vs tail latency</h3>
        <span class="badge warn">tradeoff</span>
      </div>
      <div class="card-body">
        
          <p>Fair locks reduce starvation risk but can lower throughput by increasing context switches and reducing batching. Choose fairness when predictability matters more than raw throughput.</p>
        
      </div>
      
    </div>
    

    <div class="card" data-searchable="Read-write locks: when they help 
          Read-write locks help when reads are frequent, write critical sections are small, and the invariant can tolerate concurrent readers. If writes are frequent or readers do nontrivial work whi">
      <div class="card-header">
        <h3>Read-write locks: when they help</h3>
        <span class="badge ok">rw</span>
      </div>
      <div class="card-body">
        
          <p>Read-write locks help when reads are frequent, write critical sections are small, and the invariant can tolerate concurrent readers. If writes are frequent or readers do nontrivial work while holding the read lock, benefits vanish.</p>
        
      </div>
      
    </div>
    </div>
    </div>
  </div>

  <div class="footer">
    <div class="container">
      <p><b>Navigation:</b> <a href="chapter-12-testing-concurrent-programs.html">← Prev</a> · <a href="index.html#chapters">All chapters</a> · <a href="chapter-14-building-custom-synchronizers.html">Next →</a></p>
      <p style="margin-top:8px">This atlas is a study aid with original explanations and simulations; it does not include the book’s text.</p>
    </div>
  </div>


  <div id="toast" class="toast" role="status" aria-live="polite"></div>
  <script src="assets/app.js"></script>
</body>
</html>