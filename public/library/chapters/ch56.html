<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TLPI v2 — Chapter 56 — Sockets: Introduction</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800;900&family=JetBrains+Mono:wght@300;400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css"/>
</head>
<body>
  <header class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="logo"></div>
        <div style="min-width:0">
          <h1>TLPI Interactive Library <span class="muted2">v2</span></h1>
          <div class="sub" id="subTitle">Chapter 56 — Sockets: Introduction</div>
        </div>
      </div>
      <div class="actions">
        <span class="pill"><strong data-theme-badge>Dark</strong><span class="muted2">•</span><span class="muted">Theme</span></span>
        <button class="btn small" data-theme-toggle>Toggle</button>
        <a class="btn small ghost" href="../index.html">Index</a>
        <a class="btn small" data-prev disabled href="#" title="Previous (Ctrl/⌘+←)">Prev</a>
        <a class="btn small primary" data-next disabled href="#" title="Next (Ctrl/⌘+→)">Next</a>
      </div>
    </div>
    <div class="progress" id="scrollProgress"></div>
  </header>

  <div class="layout">
    <div class="shell">
      <aside class="sidebar">
        <div class="glass pad">
          <div class="section-title">Chapters</div>
          <input class="input" id="navSearch" placeholder="Search (press /)…"/>
          <div id="navList" class="navlist"></div>
        </div>

        <div class="glass pad" style="margin-top:12px">
          <div class="section-title">Chapter metadata</div>
          <div class="muted2 small" style="margin-top:8px">Reference: TLPI PDF page index <span class="mono">1193</span> (0-based index 1192).</div>
          <div class="muted2 small" style="margin-top:8px">Theme: <span class="pill"><strong>net</strong></span></div>
          <div style="margin-top:10px; display:flex; flex-wrap:wrap; gap:8px"><span class="pill"><strong>TCP/IP</strong></span> <span class="pill"><strong>unix domain</strong></span> <span class="pill"><strong>nonblocking</strong></span> <span class="pill"><strong>epoll</strong></span></div>
          <hr class="sep"/>
          <div class="muted2 small">Keyboard:</div>
          <div class="muted small" style="margin-top:6px">
            <span class="pill"><span class="mono">/</span> search</span>
            <span class="pill"><span class="mono">Ctrl/⌘ + ←/→</span> nav</span>
          </div>
        </div>
      </aside>

      <main>
        <div class="glass hero">
          <h2 style="background:linear-gradient(90deg, rgba(124,58,237,.92), rgba(6,182,212,.86)); -webkit-background-clip:text; background-clip:text; color:transparent">
            Chapter 56 — Sockets: Introduction
          </h2>
          <div class="subtitle">
            <p>Sockets are file descriptors with protocol state. Once you internalize that, networking becomes a composition problem: nonblocking I/O, buffering, backpressure, and state machines. TCP adds its own realities: handshake, retransmissions, congestion control, TIME_WAIT, and half-close behavior.</p><p>This guide highlights server design patterns: accept loops, connection handling strategies, timeouts, and how to observe the system (ss, tcpdump, strace).</p>
          </div>
          <div class="callouts"><div class="callout good">
  <div class="k">Invariant</div>
  <div class="v">A socket is a file descriptor with protocol state and buffers.</div>
</div><div class="callout warn">
  <div class="k">Operational risk</div>
  <div class="v">Nonblocking connect() returns EINPROGRESS; you must poll for writability and then check SO_ERROR.</div>
</div></div>
        </div>

        <div class="glass pad-lg">
          <h3 class="section" data-toc="Mental model">Mental model</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            Internalize these bullets. If you can explain them clearly, you can debug most real-world incidents in this area.
          </div>
          <div class="prose">
            <ul><li>A socket is a file descriptor plus protocol state and kernel buffers.</li><li>TCP is a state machine; your application must handle connect/accept/close transitions.</li><li>Nonblocking mode turns I/O into explicit scheduling (EINPROGRESS, EAGAIN, readiness).</li><li>Backpressure is a feature: when buffers fill, stop writing and resume later.</li><li>Server design is about bounding work per connection and isolating slow clients.</li><li>Observe the system: ss/tcpdump/strace tell you the truth about network behavior.</li></ul>
          </div>
          <hr class="sep"/>
          <div class="muted2 small" style="margin-bottom:10px">Key terms & kernel objects</div>
          <table class="table">
  <thead><tr><th>Term / object</th><th>Meaning</th></tr></thead>
  <tbody><tr><td class='mono'>Socket</td><td>File descriptor with protocol state (TCP/UDP/UNIX) and send/recv buffers.</td></tr><tr><td class='mono'>Listen socket</td><td>Passive socket that queues connection requests; accept() returns connected sockets.</td></tr><tr><td class='mono'>EINPROGRESS</td><td>Nonblocking connect in progress; complete via poll/epoll writability + SO_ERROR.</td></tr><tr><td class='mono'>TIME_WAIT</td><td>TCP state on active close to handle delayed packets; normal and expected.</td></tr><tr><td class='mono'>Backpressure</td><td>Mechanism to stop producers when consumers can&#x27;t keep up (EAGAIN, buffer limits).</td></tr><tr><td class='mono'>epoll</td><td>Readiness notification API; returns ready set instead of scanning all fds.</td></tr></tbody>
</table>
        </div>

        <div class="glass pad-lg">
  <h3 class="section" data-toc="Interactive labs">Interactive labs</h3>
  <div class="muted" style="margin-top:-4px; margin-bottom:12px">
    Poke the simulators to build intuition. These labs are educational models (not exact kernel behavior) but preserve key invariants.
  </div>
  <div id="kg_ch56"></div>
<div id="sock_ch56"></div>
<div id="str_ch56"></div>
</div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="API quick reference">API quick reference</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            A compact map of the APIs and their sharp edges. Always verify details with <span class="mono">man 2/3</span>.
          </div>
          <table class="table">
  <thead>
    <tr>
      <th>API</th>
      <th>Signature / shape</th>
      <th>Common errno</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr><td class='mono'>socket</td><td class='mono'>int socket(int domain, int type, int protocol);</td><td class='mono muted2'>EAFNOSUPPORT, EPROTONOSUPPORT, EMFILE, ENFILE</td><td>Creates a socket fd. Use SOCK_CLOEXEC / SOCK_NONBLOCK to avoid races.</td></tr><tr><td class='mono'>bind</td><td class='mono'>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</td><td class='mono muted2'>EADDRINUSE, EACCES, EINVAL</td><td>Associates local address/port. For servers, pair with listen().</td></tr><tr><td class='mono'>listen</td><td class='mono'>int listen(int sockfd, int backlog);</td><td class='mono muted2'>EADDRINUSE, EBADF, EINVAL</td><td>Marks as passive socket. backlog interacts with SYN/accept queues and kernel settings.</td></tr><tr><td class='mono'>accept4</td><td class='mono'>int accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags);</td><td class='mono muted2'>EAGAIN, EINTR, ECONNABORTED</td><td>Accepts connection; use SOCK_CLOEXEC|SOCK_NONBLOCK via accept4 to avoid fd races.</td></tr><tr><td class='mono'>connect</td><td class='mono'>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</td><td class='mono muted2'>EINPROGRESS, ECONNREFUSED, ETIMEDOUT, EHOSTUNREACH</td><td>In nonblocking mode returns EINPROGRESS; use poll/epoll for writability then check SO_ERROR.</td></tr><tr><td class='mono'>send</td><td class='mono'>ssize_t send(int sockfd, const void *buf, size_t len, int flags);</td><td class='mono muted2'>EPIPE, EAGAIN, EINTR</td><td>May be short; handle EAGAIN for nonblocking. SIGPIPE can be suppressed with MSG_NOSIGNAL.</td></tr><tr><td class='mono'>recv</td><td class='mono'>ssize_t recv(int sockfd, void *buf, size_t len, int flags);</td><td class='mono muted2'>EAGAIN, EINTR</td><td>0 indicates orderly shutdown. May be short. Use MSG_WAITALL carefully.</td></tr>
  </tbody>
</table>
          <div class="muted2 small" style="margin-top:12px">
            Tip: always log enough context for errno to be actionable (inputs, flags, sizes).
          </div>
        </div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Edge cases & invariants">Edge cases & invariants</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            This is where production bugs live. Expand each panel and treat the bullets as test cases.
          </div>
          <details class="accordion">
  <summary>TCP state machine: what servers actually deal with</summary>
  <div class="content"><ul><li>connect() initiates handshake (SYN). The server’s listen socket queues connections before accept() returns a connected socket.</li><li>Nonblocking connect returns EINPROGRESS; completion is detected via poll/epoll writability then SO_ERROR.</li><li>Half-close exists: one side can shutdown(SHUT_WR) while still reading. recv()==0 means FIN received.</li><li>TIME_WAIT is normal for active close; reuse needs care (SO_REUSEADDR) and a good understanding of 4-tuples.</li></ul></div>
</details><details class="accordion">
  <summary>Backpressure and buffers</summary>
  <div class="content"><ul><li>The kernel has send/receive buffers. If your app doesn’t read, the peer eventually blocks or drops based on protocol and timeouts.</li><li>Short writes happen; treat EAGAIN as a signal to stop writing and wait for EPOLLOUT.</li><li>Nagle (TCP_NODELAY) and delayed ACKs interact with small writes; batch writes when possible.</li><li>Always set timeouts (connect, read, write, idle) to avoid hanging connections.</li></ul></div>
</details><details class="accordion">
  <summary>Server design: scaling patterns</summary>
  <div class="content"><ul><li>Thread-per-connection is simple but can be memory heavy. Event loops scale when per-connection work is bounded and nonblocking.</li><li>Use accept4 with SOCK_NONBLOCK|SOCK_CLOEXEC to avoid races and simplify setup.</li><li>Consider load shedding: cap accept rate, apply per-IP limits, and bound queues to prevent collapse under overload.</li><li>Measure: accept rate, SYN backlog drops, retransmissions, tail latency, and CPU spent in softirq/network stack.</li></ul></div>
</details><details class="accordion">
  <summary>Debugging workflow</summary>
  <div class="content"><ul><li>ss -antp gives state and owning process. tcpdump/wireshark reveals handshake and retransmissions.</li><li>strace -f -e trace=network shows socket syscalls and errno (ECONNREFUSED, ETIMEDOUT).</li><li>Check /proc/sys/net/* for kernel tuning and listen backlog limits.</li><li>For high packet rates, perf can show time in tcp_recvmsg, tcp_sendmsg, and softirq handlers.</li></ul></div>
</details>
        </div>

        <div class="glass pad-lg">
  <div style="display:flex; align-items:center; justify-content:space-between; gap:10px">
    <h3 class="section" data-toc="Code patterns">Code patterns (C / POSIX) </h3>
    <button class="btn small" data-copy="#code_ch56">Copy</button>
  </div>
  <div class="muted" style="margin-top:-4px; margin-bottom:12px">
    These are compact patterns to internalize. Treat them as starting points: add proper error handling, timeouts, and logging.
  </div>
  <pre id="code_ch56"><code class="mono">// Minimal TCP server sketch (error handling omitted for brevity)
int s = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC, 0);

int yes = 1;
setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(yes));

struct sockaddr_in addr = {0};
addr.sin_family = AF_INET;
addr.sin_addr.s_addr = htonl(INADDR_ANY);
addr.sin_port = htons(8080);

bind(s, (struct sockaddr*)&amp;addr, sizeof(addr));
listen(s, 128);

for (;;) {
  int c = accept4(s, NULL, NULL, SOCK_CLOEXEC);
  if (c &lt; 0) continue;
  send(c, &quot;hi\n&quot;, 3, MSG_NOSIGNAL);
  close(c);
}</code></pre>
</div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Production checklist">Production checklist</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            If you are shipping code in this area, try to satisfy each checklist item explicitly.
          </div>
          <div class="prose">
            <ul><li>Use SOCK_CLOEXEC/SOCK_NONBLOCK and accept4 to avoid races and simplify setup.</li><li>Implement backpressure: bounded buffers, stop writing on EAGAIN, and resume on EPOLLOUT.</li><li>Set timeouts (connect/read/write/idle) and handle half-closes correctly.</li><li>Instrument: connection counts, queue depths, bytes in/out, and tail latencies.</li><li>Use ss/tcpdump/perf for debugging; don’t guess about network states.</li></ul>
          </div>
        </div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Exercises">Exercises</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            Hands-on tasks to make the chapter “stick”. These are intentionally practical and debugging-heavy.
          </div>
          <div class="prose">
            <ul><li>Build a TCP echo server; add SO_REUSEADDR and observe restart behavior.</li><li>Switch to nonblocking + epoll; handle EAGAIN correctly and implement per-connection output buffers.</li><li>Use ss -antp during load to observe states (SYN-RECV, ESTAB, TIME-WAIT).</li></ul>
          </div>
        </div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Quiz">Quiz</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            Click an option to check your understanding. The explanation points to the underlying invariant.
          </div>
          <div class="quiz"><div class="q" data-quiz data-answer="1" data-explain="listen marks the socket as passive and creates queues for incoming connections.">
  <div class="qp">Q1. listen() creates:</div>
  <div class="opts"><div class="opt" data-opt="0">
  <div class="dot"></div>
  <div><div style="font-weight:750">A connected socket</div></div>
</div><div class="opt" data-opt="1">
  <div class="dot"></div>
  <div><div style="font-weight:750">A listening socket that queues connection requests</div></div>
</div><div class="opt" data-opt="2">
  <div class="dot"></div>
  <div><div style="font-weight:750">A UDP socket</div></div>
</div><div class="opt" data-opt="3">
  <div class="dot"></div>
  <div><div style="font-weight:750">A thread pool</div></div>
</div></div>
  <div class="feedback muted2 small"></div>
</div><div class="q" data-quiz data-answer="1" data-explain="0 bytes indicates EOF on the connection: the peer closed its write side.">
  <div class="qp">Q2. What does recv() returning 0 mean on TCP?</div>
  <div class="opts"><div class="opt" data-opt="0">
  <div class="dot"></div>
  <div><div style="font-weight:750">Temporary no data</div></div>
</div><div class="opt" data-opt="1">
  <div class="dot"></div>
  <div><div style="font-weight:750">Peer performed an orderly shutdown (FIN)</div></div>
</div><div class="opt" data-opt="2">
  <div class="dot"></div>
  <div><div style="font-weight:750">Packet loss</div></div>
</div><div class="opt" data-opt="3">
  <div class="dot"></div>
  <div><div style="font-weight:750">Socket error</div></div>
</div></div>
  <div class="feedback muted2 small"></div>
</div><div class="q" data-quiz data-answer="1" data-explain="accept4 sets flags atomically; fcntl after accept can race with exec in another thread.">
  <div class="qp">Q3. Which call avoids fd races for CLOEXEC on accepted sockets?</div>
  <div class="opts"><div class="opt" data-opt="0">
  <div class="dot"></div>
  <div><div style="font-weight:750">accept()</div></div>
</div><div class="opt" data-opt="1">
  <div class="dot"></div>
  <div><div style="font-weight:750">accept4(..., SOCK_CLOEXEC)</div></div>
</div><div class="opt" data-opt="2">
  <div class="dot"></div>
  <div><div style="font-weight:750">fcntl(FD_CLOEXEC) after accept</div></div>
</div><div class="opt" data-opt="3">
  <div class="dot"></div>
  <div><div style="font-weight:750">dup2()</div></div>
</div></div>
  <div class="feedback muted2 small"></div>
</div></div>
        </div>

        <div class="glass pad" style="margin-top:12px">
          <div class="muted2 small">
            Disclaimer: This companion is original educational content and does not reproduce TLPI’s text or figures.
            Always verify details with man pages and your target kernel/libc versions.
          </div>
        </div>
      </main>

      <aside class="righttoc">
        <div class="glass pad">
          <div class="section-title">On this page</div>
          <div id="toc" class="toc"></div>
        </div>

        <div class="glass pad" style="margin-top:12px">
          <div class="section-title">Read like an operator</div>
          <div class="muted small" style="line-height:1.7">
            <div><span class="pill"><strong>Observe</strong> strace / /proc / ss</span></div>
            <div style="margin-top:8px"><span class="pill"><strong>Model</strong> kernel objects</span></div>
            <div style="margin-top:8px"><span class="pill"><strong>Prove</strong> with tests</span></div>
            <div style="margin-top:8px"><span class="pill"><strong>Measure</strong> perf + latency</span></div>
          </div>
        </div>
      </aside>
    </div>

    <div class="footer">
      Generated 2026-02-06 20:53 UTC. Chapter 56. Static HTML. 
    </div>
  </div>

  <script src="../assets/tlpi_nav.js"></script>
  <script src="../assets/widgets.js"></script>
  <script src="../assets/ui.js"></script>
  <script>
    TLPIUI.initChapterPage({kind:"chapter", id:"ch56", n:56, subtitle:"Chapter 56 \u2014 Sockets: Introduction"});
    TLPIWidgets.mountKernelGraph("kg_ch56", {
      title: "Kernel mental model (chapter context)",
      subtitle: "Hover nodes to see what the object means. Highlighted nodes are most relevant to this chapter theme (net). Click to pin a tooltip.",
      highlight: ["socket", "tcp", "skb", "epoll", "process", "fdtable"]
    });
TLPIWidgets.mountSocketLab("sock_ch56", {});
TLPIWidgets.mountStraceParser("str_ch56", {example: "socket(AF_INET, SOCK_STREAM|SOCK_NONBLOCK|SOCK_CLOEXEC, IPPROTO_TCP) = 3\nconnect(3, {{sa_family=AF_INET, sin_port=htons(443), sin_addr=...}}, 16) = -1 EINPROGRESS (Operation now in progress)\npoll([{fd=3, events=POLLOUT}], 1, 3000) = 1\ngetsockopt(3, SOL_SOCKET, SO_ERROR, [0], [4]) = 0\n"});
  </script>
</body>
</html>
