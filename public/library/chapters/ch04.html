<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TLPI v2 — Chapter 04 — File I/O: The Universal I/O Model</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800;900&family=JetBrains+Mono:wght@300;400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css"/>
</head>
<body>
  <header class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="logo"></div>
        <div style="min-width:0">
          <h1>TLPI Interactive Library <span class="muted2">v2</span></h1>
          <div class="sub" id="subTitle">Chapter 04 — File I/O: The Universal I/O Model</div>
        </div>
      </div>
      <div class="actions">
        <span class="pill"><strong data-theme-badge>Dark</strong><span class="muted2">•</span><span class="muted">Theme</span></span>
        <button class="btn small" data-theme-toggle>Toggle</button>
        <a class="btn small ghost" href="../index.html">Index</a>
        <a class="btn small" data-prev disabled href="#" title="Previous (Ctrl/⌘+←)">Prev</a>
        <a class="btn small primary" data-next disabled href="#" title="Next (Ctrl/⌘+→)">Next</a>
      </div>
    </div>
    <div class="progress" id="scrollProgress"></div>
  </header>

  <div class="layout">
    <div class="shell">
      <aside class="sidebar">
        <div class="glass pad">
          <div class="section-title">Chapters</div>
          <input class="input" id="navSearch" placeholder="Search (press /)…"/>
          <div id="navList" class="navlist"></div>
        </div>

        <div class="glass pad" style="margin-top:12px">
          <div class="section-title">Chapter metadata</div>
          <div class="muted2 small" style="margin-top:8px">Reference: TLPI PDF page index <span class="mono">113</span> (0-based index 112).</div>
          <div class="muted2 small" style="margin-top:8px">Theme: <span class="pill"><strong>io</strong></span></div>
          <div style="margin-top:10px; display:flex; flex-wrap:wrap; gap:8px"><span class="pill"><strong>fd table</strong></span> <span class="pill"><strong>O_CLOEXEC</strong></span> <span class="pill"><strong>EINTR/EAGAIN</strong></span> <span class="pill"><strong>atomicity</strong></span></div>
          <hr class="sep"/>
          <div class="muted2 small">Keyboard:</div>
          <div class="muted small" style="margin-top:6px">
            <span class="pill"><span class="mono">/</span> search</span>
            <span class="pill"><span class="mono">Ctrl/⌘ + ←/→</span> nav</span>
          </div>
        </div>
      </aside>

      <main>
        <div class="glass hero">
          <h2 style="background:linear-gradient(90deg, rgba(124,58,237,.92), rgba(6,182,212,.86)); -webkit-background-clip:text; background-clip:text; color:transparent">
            Chapter 04 — File I/O: The Universal I/O Model
          </h2>
          <div class="subtitle">
            <p>Linux file I/O is built around a simple abstraction: an integer file descriptor that indexes a per-process table. Under the hood, the descriptor points to an *open file description* (file offset + status flags) which in turn points to an inode and the filesystem implementation. This indirection is why dup()/fork() share offsets and why O_CLOEXEC matters.</p><p>Most real bugs in I/O code come from edge cases: partial reads/writes, EINTR/EAGAIN, nonblocking mode, buffering layers (stdio vs syscalls), and durability assumptions (page cache vs stable storage). This chapter guide is designed to make those edge cases feel normal.</p>
          </div>
          <div class="callouts"><div class="callout good">
  <div class="k">Invariant</div>
  <div class="v">A file descriptor is not the file. It is an index into a per-process table that can be duplicated and inherited.</div>
</div><div class="callout warn">
  <div class="k">Common bug</div>
  <div class="v">Assuming read()/write() transfer the full buffer. In reality you must loop for partial progress.</div>
</div></div>
        </div>

        <div class="glass pad-lg">
          <h3 class="section" data-toc="Mental model">Mental model</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            Internalize these bullets. If you can explain them clearly, you can debug most real-world incidents in this area.
          </div>
          <div class="prose">
            <ul><li>Think in layers: fd → open file description → inode → filesystem → storage.</li><li>Assume partial progress and interruptions. Your code must be correct under short reads/writes and EINTR.</li><li>Nonblocking I/O turns blocking into explicit flow-control (EAGAIN + readiness notification).</li><li>Durability is separate from visibility: write() updates cache; fsync() requests stable storage.</li><li>Atomicity is about specific operations and objects (PIPE_BUF for pipes, rename within FS, O_APPEND semantics).</li><li>Always define ownership for file descriptors (who closes; when; and what happens across exec).</li></ul>
          </div>
          <hr class="sep"/>
          <div class="muted2 small" style="margin-bottom:10px">Key terms & kernel objects</div>
          <table class="table">
  <thead><tr><th>Term / object</th><th>Meaning</th></tr></thead>
  <tbody><tr><td class='mono'>FD table</td><td>Per-process map: small integers → pointers to open file descriptions.</td></tr><tr><td class='mono'>Open file description</td><td>Kernel object holding file offset + status flags; shared via dup() and fork().</td></tr><tr><td class='mono'>Page cache</td><td>Caches file-backed pages in RAM; affects reads, writes, and durability.</td></tr><tr><td class='mono'>O_CLOEXEC</td><td>Close-on-exec flag preventing FD leakage into exec&#x27;d programs; set atomically where possible.</td></tr><tr><td class='mono'>EINTR</td><td>Error indicating a blocking syscall was interrupted by a signal; requires retry logic.</td></tr><tr><td class='mono'>EAGAIN</td><td>Nonblocking operation would block; treat as flow-control and retry later.</td></tr></tbody>
</table>
        </div>

        <div class="glass pad-lg">
  <h3 class="section" data-toc="Interactive labs">Interactive labs</h3>
  <div class="muted" style="margin-top:-4px; margin-bottom:12px">
    Poke the simulators to build intuition. These labs are educational models (not exact kernel behavior) but preserve key invariants.
  </div>
  <div id="kg_ch04"></div>
<div id="fd_ch04"></div>
<div id="str_ch04"></div>
</div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="API quick reference">API quick reference</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            A compact map of the APIs and their sharp edges. Always verify details with <span class="mono">man 2/3</span>.
          </div>
          <table class="table">
  <thead>
    <tr>
      <th>API</th>
      <th>Signature / shape</th>
      <th>Common errno</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr><td class='mono'>open</td><td class='mono'>int open(const char *path, int flags, mode_t mode /* optional */);</td><td class='mono muted2'>ENOENT, EACCES, EISDIR, EMFILE, ENFILE, ENOSPC</td><td>Prefer openat() for race-resistant path handling; set O_CLOEXEC by default.</td></tr><tr><td class='mono'>openat</td><td class='mono'>int openat(int dirfd, const char *path, int flags, mode_t mode /* optional */);</td><td class='mono muted2'>ENOENT, EACCES, ENOTDIR, EMFILE, ENFILE</td><td>Compose with *at() family to avoid TOCTOU. Use AT_FDCWD for CWD.</td></tr><tr><td class='mono'>read</td><td class='mono'>ssize_t read(int fd, void *buf, size_t count);</td><td class='mono muted2'>EINTR, EAGAIN, EBADF, EFAULT</td><td>Short reads are normal (pipes/sockets/tty). Loop until done; handle EINTR and EAGAIN for nonblocking.</td></tr><tr><td class='mono'>write</td><td class='mono'>ssize_t write(int fd, const void *buf, size_t count);</td><td class='mono muted2'>EINTR, EAGAIN, EPIPE, EBADF, ENOSPC</td><td>Short writes are normal on pipes/sockets/nonblocking fds. SIGPIPE/EPIPE when peer is gone.</td></tr><tr><td class='mono'>close</td><td class='mono'>int close(int fd);</td><td class='mono muted2'>EBADF, EINTR</td><td>After close(), fd number can be reused; avoid close() races in multithreaded code.</td></tr><tr><td class='mono'>lseek</td><td class='mono'>off_t lseek(int fd, off_t offset, int whence);</td><td class='mono muted2'>ESPIPE, EINVAL, EBADF</td><td>File offset is shared across dup() and fork(); prefer pread/pwrite for thread-safe positional I/O.</td></tr>
  </tbody>
</table>
          <div class="muted2 small" style="margin-top:12px">
            Tip: always log enough context for errno to be actionable (inputs, flags, sizes).
          </div>
        </div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Edge cases & invariants">Edge cases & invariants</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            This is where production bugs live. Expand each panel and treat the bullets as test cases.
          </div>
          <details class="accordion">
  <summary>Atomicity &amp; invariants you can rely on</summary>
  <div class="content"><ul><li>A file descriptor is a *per-process* handle; the underlying open file description (OFD) is a *kernel object* that can be shared.</li><li>OFD contains the file offset and status flags. After dup() or fork(), multiple fds can reference the same OFD → shared offset.</li><li>For regular files, read/write update the file offset as part of the syscall. For O_APPEND, the kernel sets the offset to EOF atomically for each write.</li><li>Atomicity is filesystem- and operation-dependent. Example: POSIX guarantees atomic writes up to PIPE_BUF for pipes/FIFOs; regular file writes are not globally atomic across threads/processes unless you design for it.</li></ul></div>
</details><details class="accordion">
  <summary>Error-handling: the “three E’s” (EINTR, EAGAIN, EOF)</summary>
  <div class="content"><ul><li>EINTR means a signal interrupted a blocking syscall. Decide a policy: use SA_RESTART where appropriate, or loop-and-retry explicitly.</li><li>EAGAIN/EWOULDBLOCK means nonblocking I/O would block. Treat it as flow-control: register interest (poll/epoll) and retry later.</li><li>EOF is *not* an error: read() returns 0. For sockets, recv()=0 means peer performed an orderly shutdown (FIN).</li><li>Short reads/writes are normal. Write robust loops that handle partial progress without assuming “all or nothing”.</li></ul></div>
</details><details class="accordion">
  <summary>Performance notes you feel in production</summary>
  <div class="content"><ul><li>The page cache means that “write() returned” does not imply data is on disk. Durability requires fsync()/fdatasync() + careful ordering.</li><li>Avoid tiny syscalls in hot loops: batch, use larger buffers, and reduce context switches.</li><li>pread/pwrite avoid shared offset contention, often improving scalability in multi-threaded servers.</li><li>On fast storage, syscall overhead can dominate. Profiling with perf can show time in vfs, ext4, or copy_to_user/copy_from_user paths.</li></ul></div>
</details><details class="accordion">
  <summary>Debugging workflow</summary>
  <div class="content"><ul><li>Start with strace -f to see syscalls and errno. Add -tt -T to see timing.</li><li>Inspect /proc/&lt;pid&gt;/fd to confirm which files are open and where they point.</li><li>Use lsof for system-wide views and to find which process holds a lock or open file.</li><li>When performance matters, perf trace/perf record can reveal syscall hotspots and kernel stack traces.</li></ul></div>
</details>
        </div>

        <div class="glass pad-lg">
  <div style="display:flex; align-items:center; justify-content:space-between; gap:10px">
    <h3 class="section" data-toc="Code patterns">Code patterns (C / POSIX) </h3>
    <button class="btn small" data-copy="#code_ch04">Copy</button>
  </div>
  <div class="muted" style="margin-top:-4px; margin-bottom:12px">
    These are compact patterns to internalize. Treat them as starting points: add proper error handling, timeouts, and logging.
  </div>
  <pre id="code_ch04"><code class="mono">// Robust write-all loop (handles EINTR + short writes)
ssize_t write_all(int fd, const void *buf, size_t len) {
  const char *p = buf;
  size_t left = len;
  while (left &gt; 0) {
    ssize_t n = write(fd, p, left);
    if (n &gt; 0) { p += n; left -= (size_t)n; continue; }
    if (n == -1 &amp;&amp; errno == EINTR) continue;       // retry
    if (n == -1 &amp;&amp; errno == EAGAIN) return -2;     // would block (nonblocking)
    return -1;                                     // real error
  }
  return (ssize_t)len;
}</code></pre>
</div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Production checklist">Production checklist</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            If you are shipping code in this area, try to satisfy each checklist item explicitly.
          </div>
          <div class="prose">
            <ul><li>Set O_CLOEXEC / FD_CLOEXEC on all fds by default (use openat/pipe2/socket with CLOEXEC flags).</li><li>Handle partial I/O, EINTR, and EAGAIN in loops; never assume single-call completion.</li><li>Decide and document durability: if data must survive crash, use fsync/fdatasync and correct ordering.</li><li>Avoid mixing stdio and raw fd operations on the same underlying file descriptor unless you understand buffering.</li><li>Log errno with context (path, flags, fd) — it’s your future debugging time-saver.</li></ul>
          </div>
        </div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Exercises">Exercises</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            Hands-on tasks to make the chapter “stick”. These are intentionally practical and debugging-heavy.
          </div>
          <div class="prose">
            <ul><li>Write a small program that copies stdin → stdout using read/write. Add flags for O_NONBLOCK and watch behavior with pipes.</li><li>Use strace -tt -T to compare syscall counts for 1-byte vs 64KB buffers.</li><li>Demonstrate shared file offset: open a file, dup(fd), write via both fds, and show interleaving.</li></ul>
          </div>
        </div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Quiz">Quiz</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            Click an option to check your understanding. The explanation points to the underlying invariant.
          </div>
          <div class="quiz"><div class="q" data-quiz data-answer="0" data-explain="dup() creates a new descriptor that points to the same open file description (shared offset + flags).">
  <div class="qp">Q1. After dup(fd), do the two fds share file offset?</div>
  <div class="opts"><div class="opt" data-opt="0">
  <div class="dot"></div>
  <div><div style="font-weight:750">Yes — they reference the same open file description</div></div>
</div><div class="opt" data-opt="1">
  <div class="dot"></div>
  <div><div style="font-weight:750">No — each fd has independent offsets</div></div>
</div><div class="opt" data-opt="2">
  <div class="dot"></div>
  <div><div style="font-weight:750">It depends on filesystem</div></div>
</div><div class="opt" data-opt="3">
  <div class="dot"></div>
  <div><div style="font-weight:750">Only after fork()</div></div>
</div></div>
  <div class="feedback muted2 small"></div>
</div><div class="q" data-quiz data-answer="1" data-explain="EOF is signaled by a successful read returning 0 bytes.">
  <div class="qp">Q2. What does read() return at end-of-file on a regular file?</div>
  <div class="opts"><div class="opt" data-opt="0">
  <div class="dot"></div>
  <div><div style="font-weight:750">-1 with errno=EOF</div></div>
</div><div class="opt" data-opt="1">
  <div class="dot"></div>
  <div><div style="font-weight:750">0</div></div>
</div><div class="opt" data-opt="2">
  <div class="dot"></div>
  <div><div style="font-weight:750">It blocks forever</div></div>
</div><div class="opt" data-opt="3">
  <div class="dot"></div>
  <div><div style="font-weight:750">It returns the remaining bytes and sets errno</div></div>
</div></div>
  <div class="feedback muted2 small"></div>
</div><div class="q" data-quiz data-answer="1" data-explain="pread/pwrite take an explicit offset and do not modify the file offset in the open file description.">
  <div class="qp">Q3. Which pattern avoids shared-offset races in multithreaded code?</div>
  <div class="opts"><div class="opt" data-opt="0">
  <div class="dot"></div>
  <div><div style="font-weight:750">lseek+read</div></div>
</div><div class="opt" data-opt="1">
  <div class="dot"></div>
  <div><div style="font-weight:750">pread</div></div>
</div><div class="opt" data-opt="2">
  <div class="dot"></div>
  <div><div style="font-weight:750">dup2</div></div>
</div><div class="opt" data-opt="3">
  <div class="dot"></div>
  <div><div style="font-weight:750">close+open</div></div>
</div></div>
  <div class="feedback muted2 small"></div>
</div></div>
        </div>

        <div class="glass pad" style="margin-top:12px">
          <div class="muted2 small">
            Disclaimer: This companion is original educational content and does not reproduce TLPI’s text or figures.
            Always verify details with man pages and your target kernel/libc versions.
          </div>
        </div>
      </main>

      <aside class="righttoc">
        <div class="glass pad">
          <div class="section-title">On this page</div>
          <div id="toc" class="toc"></div>
        </div>

        <div class="glass pad" style="margin-top:12px">
          <div class="section-title">Read like an operator</div>
          <div class="muted small" style="line-height:1.7">
            <div><span class="pill"><strong>Observe</strong> strace / /proc / ss</span></div>
            <div style="margin-top:8px"><span class="pill"><strong>Model</strong> kernel objects</span></div>
            <div style="margin-top:8px"><span class="pill"><strong>Prove</strong> with tests</span></div>
            <div style="margin-top:8px"><span class="pill"><strong>Measure</strong> perf + latency</span></div>
          </div>
        </div>
      </aside>
    </div>

    <div class="footer">
      Generated 2026-02-06 20:53 UTC. Chapter 04. Static HTML. 
    </div>
  </div>

  <script src="../assets/tlpi_nav.js"></script>
  <script src="../assets/widgets.js"></script>
  <script src="../assets/ui.js"></script>
  <script>
    TLPIUI.initChapterPage({kind:"chapter", id:"ch04", n:4, subtitle:"Chapter 04 \u2014 File I/O: The Universal I/O Model"});
    TLPIWidgets.mountKernelGraph("kg_ch04", {
      title: "Kernel mental model (chapter context)",
      subtitle: "Hover nodes to see what the object means. Highlighted nodes are most relevant to this chapter theme (io). Click to pin a tooltip.",
      highlight: ["fdtable", "file", "inode", "pagecache", "pipe", "epoll"]
    });
TLPIWidgets.mountFDLab("fd_ch04", {});
TLPIWidgets.mountStraceParser("str_ch04", {example: "openat(AT_FDCWD, \"/etc/hosts\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"...\", 4096) = 172\nclose(3) = 0\nopenat(AT_FDCWD, \"/nope\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\n"});
  </script>
</body>
</html>
