<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TLPI v2 — Chapter 20 — Signals: Fundamental Concepts</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800;900&family=JetBrains+Mono:wght@300;400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css"/>
</head>
<body>
  <header class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="logo"></div>
        <div style="min-width:0">
          <h1>TLPI Interactive Library <span class="muted2">v2</span></h1>
          <div class="sub" id="subTitle">Chapter 20 — Signals: Fundamental Concepts</div>
        </div>
      </div>
      <div class="actions">
        <span class="pill"><strong data-theme-badge>Dark</strong><span class="muted2">•</span><span class="muted">Theme</span></span>
        <button class="btn small" data-theme-toggle>Toggle</button>
        <a class="btn small ghost" href="../index.html">Index</a>
        <a class="btn small" data-prev disabled href="#" title="Previous (Ctrl/⌘+←)">Prev</a>
        <a class="btn small primary" data-next disabled href="#" title="Next (Ctrl/⌘+→)">Next</a>
      </div>
    </div>
    <div class="progress" id="scrollProgress"></div>
  </header>

  <div class="layout">
    <div class="shell">
      <aside class="sidebar">
        <div class="glass pad">
          <div class="section-title">Chapters</div>
          <input class="input" id="navSearch" placeholder="Search (press /)…"/>
          <div id="navList" class="navlist"></div>
        </div>

        <div class="glass pad" style="margin-top:12px">
          <div class="section-title">Chapter metadata</div>
          <div class="muted2 small" style="margin-top:8px">Reference: TLPI PDF page index <span class="mono">431</span> (0-based index 430).</div>
          <div class="muted2 small" style="margin-top:8px">Theme: <span class="pill"><strong>signals</strong></span></div>
          <div style="margin-top:10px; display:flex; flex-wrap:wrap; gap:8px"><span class="pill"><strong>sigaction</strong></span> <span class="pill"><strong>masks</strong></span> <span class="pill"><strong>handlers</strong></span> <span class="pill"><strong>EINTR</strong></span></div>
          <hr class="sep"/>
          <div class="muted2 small">Keyboard:</div>
          <div class="muted small" style="margin-top:6px">
            <span class="pill"><span class="mono">/</span> search</span>
            <span class="pill"><span class="mono">Ctrl/⌘ + ←/→</span> nav</span>
          </div>
        </div>
      </aside>

      <main>
        <div class="glass hero">
          <h2 style="background:linear-gradient(90deg, rgba(124,58,237,.92), rgba(6,182,212,.86)); -webkit-background-clip:text; background-clip:text; color:transparent">
            Chapter 20 — Signals: Fundamental Concepts
          </h2>
          <div class="subtitle">
            <p>Signals are asynchronous control flow injected by the kernel. They’re powerful (timeouts, termination, child tracking) and dangerous (reentrancy, interrupted syscalls, handler safety). If you treat signals as “rare”, you’ll ship fragile code; if you treat them as a first-class concurrency primitive, you can build robust supervisors and event loops.</p><p>This guide focuses on signal *mechanics*: dispositions, masks, pending queues, SA_RESTART vs EINTR, and safe patterns (self-pipe/signalfd, flag + main loop).</p>
          </div>
          <div class="callouts"><div class="callout good">
  <div class="k">Invariant</div>
  <div class="v">Signals are delivered to threads; each thread has its own signal mask.</div>
</div><div class="callout warn">
  <div class="k">Common bug</div>
  <div class="v">Doing complex work inside a handler (malloc/printf) → deadlocks and corruption.</div>
</div></div>
        </div>

        <div class="glass pad-lg">
          <h3 class="section" data-toc="Mental model">Mental model</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            Internalize these bullets. If you can explain them clearly, you can debug most real-world incidents in this area.
          </div>
          <div class="prose">
            <ul><li>Signals are asynchronous events delivered to threads with per-thread masks.</li><li>Handlers are interrupt contexts: minimal work, async-signal-safe only.</li><li>EINTR is a normal outcome; write loops that preserve deadlines.</li><li>Use sigaction to specify flags (SA_RESTART/SA_SIGINFO) and handler masks.</li><li>Pending signals deliver when unblocked; standard signals may coalesce.</li><li>For event loops, signalfd/self-pipe converts signals into fd readability.</li></ul>
          </div>
          <hr class="sep"/>
          <div class="muted2 small" style="margin-bottom:10px">Key terms & kernel objects</div>
          <table class="table">
  <thead><tr><th>Term / object</th><th>Meaning</th></tr></thead>
  <tbody><tr><td class='mono'>Disposition</td><td>Per-signal behavior: default, ignore, or user handler (sigaction).</td></tr><tr><td class='mono'>Mask</td><td>Per-thread set of blocked signals; blocked signals become pending.</td></tr><tr><td class='mono'>Pending</td><td>Signals that have been generated but not yet delivered due to masking.</td></tr><tr><td class='mono'>SA_RESTART</td><td>Flag that causes some syscalls to restart after handler returns instead of returning EINTR.</td></tr><tr><td class='mono'>Async-signal-safe</td><td>Functions safe to call in a handler (e.g., write, _exit).</td></tr><tr><td class='mono'>signalfd</td><td>Linux fd API to receive signals as read() events; integrates with epoll.</td></tr></tbody>
</table>
        </div>

        <div class="glass pad-lg">
  <h3 class="section" data-toc="Interactive labs">Interactive labs</h3>
  <div class="muted" style="margin-top:-4px; margin-bottom:12px">
    Poke the simulators to build intuition. These labs are educational models (not exact kernel behavior) but preserve key invariants.
  </div>
  <div id="kg_ch20"></div>
<div id="sig_ch20"></div>
<div id="str_ch20"></div>
</div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="API quick reference">API quick reference</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            A compact map of the APIs and their sharp edges. Always verify details with <span class="mono">man 2/3</span>.
          </div>
          <table class="table">
  <thead>
    <tr>
      <th>API</th>
      <th>Signature / shape</th>
      <th>Common errno</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr><td class='mono'>kill</td><td class='mono'>int kill(pid_t pid, int sig);</td><td class='mono muted2'>ESRCH, EINVAL, EPERM</td><td>Send a signal. With pid &lt; 0, targets process groups; with pid=0, current process group.</td></tr><tr><td class='mono'>sigaction</td><td class='mono'>int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</td><td class='mono muted2'>EINVAL, EFAULT</td><td>Modern signal handler API; supports SA_RESTART, SA_SIGINFO, signal masks per handler.</td></tr><tr><td class='mono'>sigprocmask</td><td class='mono'>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</td><td class='mono muted2'>EINVAL, EFAULT</td><td>Blocks/unblocks signals for the calling thread (in NPTL). Use pthread_sigmask in threaded apps.</td></tr><tr><td class='mono'>sigsuspend</td><td class='mono'>int sigsuspend(const sigset_t *mask);</td><td class='mono muted2'>EINTR</td><td>Atomically swaps mask and sleeps until a signal arrives—avoids race windows.</td></tr>
  </tbody>
</table>
          <div class="muted2 small" style="margin-top:12px">
            Tip: always log enough context for errno to be actionable (inputs, flags, sizes).
          </div>
        </div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Edge cases & invariants">Edge cases & invariants</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            This is where production bugs live. Expand each panel and treat the bullets as test cases.
          </div>
          <details class="accordion">
  <summary>Mask + pending queue: how to think about delivery</summary>
  <div class="content"><ul><li>Each thread has a signal mask. A blocked signal becomes pending; it is delivered when unblocked.</li><li>Some signals coalesce (standard signals): multiple occurrences may merge into one pending instance; real-time signals can queue with data.</li><li>SIGKILL and SIGSTOP cannot be caught or blocked — design shutdown strategies accordingly.</li><li>Signal handlers run on the interrupted thread, on its stack (unless alt stack configured), with strict reentrancy constraints.</li></ul></div>
</details><details class="accordion">
  <summary>SA_RESTART vs EINTR: choose intentionally</summary>
  <div class="content"><ul><li>With SA_RESTART, many blocking syscalls restart automatically after the handler returns. This reduces boilerplate but can hide wakeups.</li><li>Without SA_RESTART, syscalls return -1/EINTR and you control retry. This is often clearer for event loops and timeouts.</li><li>Always write code so that EINTR is safe even if you think it “won’t happen”. Production systems run with timers and signals.</li><li>If you use timeouts, consider clockconsiderations: restarting a syscall can extend the actual sleep beyond the intended deadline.</li></ul></div>
</details><details class="accordion">
  <summary>Safe handler patterns</summary>
  <div class="content"><ul><li>Keep handlers tiny: set an atomic flag, write to a self-pipe/eventfd, or use signalfd to move handling into the main loop.</li><li>Only call async-signal-safe functions inside handlers. printf/malloc are not safe.</li><li>Use sigaction rather than signal(); specify masks to prevent handler reentrancy for the same signal when needed.</li><li>Test with high signal rates; races show up under stress.</li></ul></div>
</details><details class="accordion">
  <summary>Debugging workflow</summary>
  <div class="content"><ul><li>strace can show EINTR and which syscalls were interrupted. Use -e trace=signal.</li><li>gdb can be configured to stop/pass/ignore signals; inspect siginfo_t for details.</li><li>Check /proc/&lt;pid&gt;/status for pending/blocked signals (SigPnd, ShdPnd, SigBlk).</li><li>If signals are used for shutdown, ensure the process cannot deadlock in a handler or during cleanup.</li></ul></div>
</details>
        </div>

        <div class="glass pad-lg">
  <div style="display:flex; align-items:center; justify-content:space-between; gap:10px">
    <h3 class="section" data-toc="Code patterns">Code patterns (C / POSIX) </h3>
    <button class="btn small" data-copy="#code_ch20">Copy</button>
  </div>
  <div class="muted" style="margin-top:-4px; margin-bottom:12px">
    These are compact patterns to internalize. Treat them as starting points: add proper error handling, timeouts, and logging.
  </div>
  <pre id="code_ch20"><code class="mono">// Minimal async-signal-safe handler pattern
#include &lt;stdatomic.h&gt;
static volatile sig_atomic_t got_sigint = 0;

static void on_sigint(int sig) {
  (void)sig;
  got_sigint = 1; // set a flag; do real work in main loop
}

int main(void){
  struct sigaction sa = {0};
  sa.sa_handler = on_sigint;
  sigemptyset(&amp;sa.sa_mask);
  sa.sa_flags = SA_RESTART;
  sigaction(SIGINT, &amp;sa, NULL);

  while (!got_sigint) pause();
  // cleanup outside handler
  return 0;
}</code></pre>
</div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Production checklist">Production checklist</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            If you are shipping code in this area, try to satisfy each checklist item explicitly.
          </div>
          <div class="prose">
            <ul><li>Use sigaction (not signal) and define SA_RESTART policy intentionally.</li><li>Keep handlers async-signal-safe; move work to main loop via self-pipe/signalfd.</li><li>Design for EINTR everywhere. Even if you use SA_RESTART, assume some calls can still return EINTR.</li><li>Avoid signal-based synchronization between threads; use mutex/cond/atomics.</li><li>Test shutdown paths under load and during blocking syscalls.</li></ul>
          </div>
        </div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Exercises">Exercises</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            Hands-on tasks to make the chapter “stick”. These are intentionally practical and debugging-heavy.
          </div>
          <div class="prose">
            <ul><li>Write a program that blocks SIGTERM for 5 seconds, then unblocks it and observe pending delivery.</li><li>Create a blocking read() from stdin and send SIGALRM; compare behavior with and without SA_RESTART.</li><li>Use signalfd in a small epoll loop to handle SIGINT without an async handler.</li></ul>
          </div>
        </div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Quiz">Quiz</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            Click an option to check your understanding. The explanation points to the underlying invariant.
          </div>
          <div class="quiz"><div class="q" data-quiz data-answer="1" data-explain="SIGKILL and SIGSTOP cannot be caught or blocked.">
  <div class="qp">Q1. Which signal cannot be caught or blocked?</div>
  <div class="opts"><div class="opt" data-opt="0">
  <div class="dot"></div>
  <div><div style="font-weight:750">SIGTERM</div></div>
</div><div class="opt" data-opt="1">
  <div class="dot"></div>
  <div><div style="font-weight:750">SIGKILL</div></div>
</div><div class="opt" data-opt="2">
  <div class="dot"></div>
  <div><div style="font-weight:750">SIGINT</div></div>
</div><div class="opt" data-opt="3">
  <div class="dot"></div>
  <div><div style="font-weight:750">SIGUSR1</div></div>
</div></div>
  <div class="feedback muted2 small"></div>
</div><div class="q" data-quiz data-answer="1" data-explain="A signal interrupted a blocking syscall; you must retry or handle partial progress.">
  <div class="qp">Q2. EINTR indicates:</div>
  <div class="opts"><div class="opt" data-opt="0">
  <div class="dot"></div>
  <div><div style="font-weight:750">End of file</div></div>
</div><div class="opt" data-opt="1">
  <div class="dot"></div>
  <div><div style="font-weight:750">Interrupted syscall</div></div>
</div><div class="opt" data-opt="2">
  <div class="dot"></div>
  <div><div style="font-weight:750">Out of memory</div></div>
</div><div class="opt" data-opt="3">
  <div class="dot"></div>
  <div><div style="font-weight:750">Bad file descriptor</div></div>
</div></div>
  <div class="feedback muted2 small"></div>
</div><div class="q" data-quiz data-answer="2" data-explain="write(2) is async-signal-safe; many libc calls are not.">
  <div class="qp">Q3. Inside a handler, which is typically async-signal-safe?</div>
  <div class="opts"><div class="opt" data-opt="0">
  <div class="dot"></div>
  <div><div style="font-weight:750">printf()</div></div>
</div><div class="opt" data-opt="1">
  <div class="dot"></div>
  <div><div style="font-weight:750">malloc()</div></div>
</div><div class="opt" data-opt="2">
  <div class="dot"></div>
  <div><div style="font-weight:750">write()</div></div>
</div><div class="opt" data-opt="3">
  <div class="dot"></div>
  <div><div style="font-weight:750">pthread_mutex_lock()</div></div>
</div></div>
  <div class="feedback muted2 small"></div>
</div></div>
        </div>

        <div class="glass pad" style="margin-top:12px">
          <div class="muted2 small">
            Disclaimer: This companion is original educational content and does not reproduce TLPI’s text or figures.
            Always verify details with man pages and your target kernel/libc versions.
          </div>
        </div>
      </main>

      <aside class="righttoc">
        <div class="glass pad">
          <div class="section-title">On this page</div>
          <div id="toc" class="toc"></div>
        </div>

        <div class="glass pad" style="margin-top:12px">
          <div class="section-title">Read like an operator</div>
          <div class="muted small" style="line-height:1.7">
            <div><span class="pill"><strong>Observe</strong> strace / /proc / ss</span></div>
            <div style="margin-top:8px"><span class="pill"><strong>Model</strong> kernel objects</span></div>
            <div style="margin-top:8px"><span class="pill"><strong>Prove</strong> with tests</span></div>
            <div style="margin-top:8px"><span class="pill"><strong>Measure</strong> perf + latency</span></div>
          </div>
        </div>
      </aside>
    </div>

    <div class="footer">
      Generated 2026-02-06 20:53 UTC. Chapter 20. Static HTML. 
    </div>
  </div>

  <script src="../assets/tlpi_nav.js"></script>
  <script src="../assets/widgets.js"></script>
  <script src="../assets/ui.js"></script>
  <script>
    TLPIUI.initChapterPage({kind:"chapter", id:"ch20", n:20, subtitle:"Chapter 20 \u2014 Signals: Fundamental Concepts"});
    TLPIWidgets.mountKernelGraph("kg_ch20", {
      title: "Kernel mental model (chapter context)",
      subtitle: "Hover nodes to see what the object means. Highlighted nodes are most relevant to this chapter theme (signals). Click to pin a tooltip.",
      highlight: ["signal", "process", "thread", "timer", "scheduler"]
    });
TLPIWidgets.mountSignalLab("sig_ch20", {});
TLPIWidgets.mountStraceParser("str_ch20", {example: "rt_sigaction(SIGINT, {sa_handler=0x401020, sa_flags=SA_RESTART}, NULL, 8) = 0\nread(0, 0x7ffd..., 1024) = -1 EINTR (Interrupted system call)\n--- SIGINT {si_signo=SIGINT, si_code=SI_KERNEL} ---\n"});
  </script>
</body>
</html>
