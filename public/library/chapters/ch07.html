<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TLPI v2 — Chapter 07 — Memory Allocation</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800;900&family=JetBrains+Mono:wght@300;400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css"/>
</head>
<body>
  <header class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="logo"></div>
        <div style="min-width:0">
          <h1>TLPI Interactive Library <span class="muted2">v2</span></h1>
          <div class="sub" id="subTitle">Chapter 07 — Memory Allocation</div>
        </div>
      </div>
      <div class="actions">
        <span class="pill"><strong data-theme-badge>Dark</strong><span class="muted2">•</span><span class="muted">Theme</span></span>
        <button class="btn small" data-theme-toggle>Toggle</button>
        <a class="btn small ghost" href="../index.html">Index</a>
        <a class="btn small" data-prev disabled href="#" title="Previous (Ctrl/⌘+←)">Prev</a>
        <a class="btn small primary" data-next disabled href="#" title="Next (Ctrl/⌘+→)">Next</a>
      </div>
    </div>
    <div class="progress" id="scrollProgress"></div>
  </header>

  <div class="layout">
    <div class="shell">
      <aside class="sidebar">
        <div class="glass pad">
          <div class="section-title">Chapters</div>
          <input class="input" id="navSearch" placeholder="Search (press /)…"/>
          <div id="navList" class="navlist"></div>
        </div>

        <div class="glass pad" style="margin-top:12px">
          <div class="section-title">Chapter metadata</div>
          <div class="muted2 small" style="margin-top:8px">Reference: TLPI PDF page index <span class="mono">183</span> (0-based index 182).</div>
          <div class="muted2 small" style="margin-top:8px">Theme: <span class="pill"><strong>mem</strong></span></div>
          <div style="margin-top:10px; display:flex; flex-wrap:wrap; gap:8px"><span class="pill"><strong>mmap</strong></span> <span class="pill"><strong>page faults</strong></span> <span class="pill"><strong>RSS vs VIRT</strong></span> <span class="pill"><strong>allocator</strong></span></div>
          <hr class="sep"/>
          <div class="muted2 small">Keyboard:</div>
          <div class="muted small" style="margin-top:6px">
            <span class="pill"><span class="mono">/</span> search</span>
            <span class="pill"><span class="mono">Ctrl/⌘ + ←/→</span> nav</span>
          </div>
        </div>
      </aside>

      <main>
        <div class="glass hero">
          <h2 style="background:linear-gradient(90deg, rgba(124,58,237,.92), rgba(6,182,212,.86)); -webkit-background-clip:text; background-clip:text; color:transparent">
            Chapter 07 — Memory Allocation
          </h2>
          <div class="subtitle">
            <p>Virtual memory is the operating system’s trick for turning physical RAM into a flexible illusion. Your program sees a flat address space; the kernel tracks mappings (VMAs), page tables, and backing stores (anonymous memory or files). Most memory performance problems are really about page faults, cache locality, and the cost of moving pages between RAM and disk.</p><p>This guide emphasizes the operational view: how malloc relates to brk/mmap, what RSS/VIRT mean, how copy-on-write works, and which VM syscalls matter when you build allocators, caches, and high-throughput servers.</p>
          </div>
          <div class="callouts"><div class="callout good">
  <div class="k">Invariant</div>
  <div class="v">Address space is mappings (VMAs); page faults bring pages in on demand.</div>
</div><div class="callout warn">
  <div class="k">Gotcha</div>
  <div class="v">High VIRT is not necessarily bad; RSS is what consumes RAM.</div>
</div><div class="callout tip">
  <div class="k">Debugging</div>
  <div class="v">Inspect /proc/&lt;pid&gt;/maps and smaps; measure page faults with perf stat.</div>
</div></div>
        </div>

        <div class="glass pad-lg">
          <h3 class="section" data-toc="Mental model">Mental model</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            Internalize these bullets. If you can explain them clearly, you can debug most real-world incidents in this area.
          </div>
          <div class="prose">
            <ul><li>Your address space is a set of mappings (VMAs) that fault pages in on demand.</li><li>RSS measures resident pages; VIRT measures address space reservation.</li><li>mmap maps files or anonymous memory; page faults are the cost of first-touch.</li><li>Copy-on-write makes fork cheap; writing triggers page duplication.</li><li>mprotect + guard pages can harden and debug memory bugs.</li><li>Allocator behavior (malloc) can dominate fragmentation and performance.</li></ul>
          </div>
          <hr class="sep"/>
          <div class="muted2 small" style="margin-bottom:10px">Key terms & kernel objects</div>
          <table class="table">
  <thead><tr><th>Term / object</th><th>Meaning</th></tr></thead>
  <tbody><tr><td class='mono'>VMA</td><td>Virtual memory area: mapping with permissions + backing store.</td></tr><tr><td class='mono'>Page fault</td><td>Trap when a page is accessed but not present; kernel loads/allocates page.</td></tr><tr><td class='mono'>RSS</td><td>Resident Set Size: pages currently in RAM for a process.</td></tr><tr><td class='mono'>VIRT</td><td>Virtual address space size; can include unmapped/reserved regions.</td></tr><tr><td class='mono'>mprotect</td><td>Changes page permissions; used for guard pages and JIT.</td></tr><tr><td class='mono'>madvise</td><td>Hints/policies for paging behavior; can drop pages or optimize access patterns.</td></tr></tbody>
</table>
        </div>

        <div class="glass pad-lg">
  <h3 class="section" data-toc="Interactive labs">Interactive labs</h3>
  <div class="muted" style="margin-top:-4px; margin-bottom:12px">
    Poke the simulators to build intuition. These labs are educational models (not exact kernel behavior) but preserve key invariants.
  </div>
  <div id="kg_ch07"></div>
</div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="API quick reference">API quick reference</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            A compact map of the APIs and their sharp edges. Always verify details with <span class="mono">man 2/3</span>.
          </div>
          <table class="table">
  <thead>
    <tr>
      <th>API</th>
      <th>Signature / shape</th>
      <th>Common errno</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr><td class='mono'>malloc</td><td class='mono'>void *malloc(size_t size);</td><td class='mono muted2'>—</td><td>Heap allocation (libc); may use brk/sbrk or mmap under the hood; failure returns NULL and sets errno.</td></tr><tr><td class='mono'>free</td><td class='mono'>void free(void *ptr);</td><td class='mono muted2'>—</td><td>Releases heap memory; double-free/use-after-free are critical bugs; consider sanitizers.</td></tr><tr><td class='mono'>mmap</td><td class='mono'>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</td><td class='mono muted2'>ENOMEM, EACCES, EINVAL, EBADF</td><td>Maps file/anon memory. Page faults happen on first touch; mind MAP_PRIVATE vs MAP_SHARED.</td></tr><tr><td class='mono'>munmap</td><td class='mono'>int munmap(void *addr, size_t length);</td><td class='mono muted2'>EINVAL</td><td>Unmaps region; dangling pointers become invalid; in multithreaded code coordinate safely.</td></tr><tr><td class='mono'>brk</td><td class='mono'>int brk(void *addr);</td><td class='mono muted2'>ENOMEM, EINVAL</td><td>Adjusts process break (heap end). Rarely used directly; malloc manages it.</td></tr>
  </tbody>
</table>
          <div class="muted2 small" style="margin-top:12px">
            Tip: always log enough context for errno to be actionable (inputs, flags, sizes).
          </div>
        </div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Edge cases & invariants">Edge cases & invariants</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            This is where production bugs live. Expand each panel and treat the bullets as test cases.
          </div>
          <details class="accordion">
  <summary>Virtual memory mental model</summary>
  <div class="content"><ul><li>The address space is a set of VMAs (mappings). Page tables map virtual pages to physical frames on demand.</li><li>Page faults are normal: first-touch allocates pages (anonymous) or loads file-backed pages from storage.</li><li>Copy-on-write means fork() can be cheap until you write; then private pages are duplicated.</li><li>RSS is resident pages; VIRT is address space size; high VIRT can be fine (mmap reservations).</li></ul></div>
</details><details class="accordion">
  <summary>Allocator behavior (malloc) and fragmentation</summary>
  <div class="content"><ul><li>malloc often uses arenas and may choose brk for small allocations and mmap for large ones (implementation-dependent).</li><li>Fragmentation can be internal (wasted inside blocks) or external (holes). Long-lived allocators need pooling strategies.</li><li>Freeing memory does not guarantee RSS drops immediately; it depends on allocator and kernel reclaim decisions.</li><li>Use tools: malloc_info, heap profilers, and /proc/&lt;pid&gt;/smaps for detailed mapping breakdown.</li></ul></div>
</details><details class="accordion">
  <summary>mmap/protection/advise in real systems</summary>
  <div class="content"><ul><li>mprotect is used for guard pages, JIT, and security hardening. Permissions changes require page alignment.</li><li>madvise hints can improve performance (sequential access) or drop pages (DONTNEED) for caches.</li><li>MAP_SHARED writes affect underlying file; durability needs msync/fsync and careful ordering.</li><li>When mapping files, choose offsets aligned to page size and handle SIGBUS on I/O errors/truncation.</li></ul></div>
</details><details class="accordion">
  <summary>Debugging workflow</summary>
  <div class="content"><ul><li>Inspect /proc/&lt;pid&gt;/maps and /proc/&lt;pid&gt;/smaps for mappings, RSS, PSS, and flags.</li><li>Use pmap for quick summaries. Use perf for page fault attribution.</li><li>For leaks, distinguish between heap leaks and mmap leaks; both show in maps.</li><li>For crashes, guard pages + ASan can catch overruns earlier.</li></ul></div>
</details>
        </div>

        <div class="glass pad-lg">
  <div style="display:flex; align-items:center; justify-content:space-between; gap:10px">
    <h3 class="section" data-toc="Code patterns">Code patterns (C / POSIX) </h3>
    <button class="btn small" data-copy="#code_ch07">Copy</button>
  </div>
  <div class="muted" style="margin-top:-4px; margin-bottom:12px">
    These are compact patterns to internalize. Treat them as starting points: add proper error handling, timeouts, and logging.
  </div>
  <pre id="code_ch07"><code class="mono">// mmap a file and touch pages (page fault demo)
int fd = open(&quot;data.bin&quot;, O_RDONLY|O_CLOEXEC);
struct stat st; fstat(fd, &amp;st);
char *p = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);

// first touch faults pages in
volatile unsigned long sum = 0;
for (off_t i=0; i&lt;st.st_size; i+=4096) sum += p[i];

munmap(p, st.st_size);
close(fd);</code></pre>
</div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Production checklist">Production checklist</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            If you are shipping code in this area, try to satisfy each checklist item explicitly.
          </div>
          <div class="prose">
            <ul><li>Measure memory with /proc/&lt;pid&gt;/smaps (RSS/PSS) and track allocations by subsystem.</li><li>Avoid unbounded caches; implement eviction and size limits.</li><li>Use mmap for large, page-aligned regions; avoid frequent map/unmap churn in hot paths.</li><li>Be wary of overcommit and OOM kills; respect rlimits/cgroups.</li><li>Use guard pages / mprotect for safety in low-level allocators.</li></ul>
          </div>
        </div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Exercises">Exercises</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            Hands-on tasks to make the chapter “stick”. These are intentionally practical and debugging-heavy.
          </div>
          <div class="prose">
            <ul><li>Map a file with mmap and measure page faults on first touch vs warm cache; observe using perf stat.</li><li>Implement an arena allocator for fixed-size objects and compare fragmentation vs malloc.</li><li>Use mprotect to create a guard page and intentionally trigger SIGSEGV to validate detection.</li></ul>
          </div>
        </div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Quiz">Quiz</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            Click an option to check your understanding. The explanation points to the underlying invariant.
          </div>
          <div class="quiz"><div class="q" data-quiz data-answer="1" data-explain="Man pages and experiments (strace) are the fastest path to correct mental models.">
  <div class="qp">Q1. What is the most reliable way to learn syscall behavior?</div>
  <div class="opts"><div class="opt" data-opt="0">
  <div class="dot"></div>
  <div><div style="font-weight:750">Guessing</div></div>
</div><div class="opt" data-opt="1">
  <div class="dot"></div>
  <div><div style="font-weight:750">Reading man 2/3 + experimenting</div></div>
</div><div class="opt" data-opt="2">
  <div class="dot"></div>
  <div><div style="font-weight:750">Copying random code</div></div>
</div><div class="opt" data-opt="3">
  <div class="dot"></div>
  <div><div style="font-weight:750">Avoiding errors</div></div>
</div></div>
  <div class="feedback muted2 small"></div>
</div><div class="q" data-quiz data-answer="1" data-explain="errno is thread-local and only meaningful immediately after a failure.">
  <div class="qp">Q2. Which is true about errno?</div>
  <div class="opts"><div class="opt" data-opt="0">
  <div class="dot"></div>
  <div><div style="font-weight:750">It is global and never changes</div></div>
</div><div class="opt" data-opt="1">
  <div class="dot"></div>
  <div><div style="font-weight:750">It is thread-local and should be read immediately</div></div>
</div><div class="opt" data-opt="2">
  <div class="dot"></div>
  <div><div style="font-weight:750">It is only for networking</div></div>
</div><div class="opt" data-opt="3">
  <div class="dot"></div>
  <div><div style="font-weight:750">It is reset to 0 after each call</div></div>
</div></div>
  <div class="feedback muted2 small"></div>
</div><div class="q" data-quiz data-answer="1" data-explain="A minimal reproduction + strace quickly reveals the failing boundary and errno.">
  <div class="qp">Q3. A good debugging approach is:</div>
  <div class="opts"><div class="opt" data-opt="0">
  <div class="dot"></div>
  <div><div style="font-weight:750">Start with perf</div></div>
</div><div class="opt" data-opt="1">
  <div class="dot"></div>
  <div><div style="font-weight:750">Start with strace and minimal reproduction</div></div>
</div><div class="opt" data-opt="2">
  <div class="dot"></div>
  <div><div style="font-weight:750">Start with rewriting everything</div></div>
</div><div class="opt" data-opt="3">
  <div class="dot"></div>
  <div><div style="font-weight:750">Ignore symptoms</div></div>
</div></div>
  <div class="feedback muted2 small"></div>
</div></div>
        </div>

        <div class="glass pad" style="margin-top:12px">
          <div class="muted2 small">
            Disclaimer: This companion is original educational content and does not reproduce TLPI’s text or figures.
            Always verify details with man pages and your target kernel/libc versions.
          </div>
        </div>
      </main>

      <aside class="righttoc">
        <div class="glass pad">
          <div class="section-title">On this page</div>
          <div id="toc" class="toc"></div>
        </div>

        <div class="glass pad" style="margin-top:12px">
          <div class="section-title">Read like an operator</div>
          <div class="muted small" style="line-height:1.7">
            <div><span class="pill"><strong>Observe</strong> strace / /proc / ss</span></div>
            <div style="margin-top:8px"><span class="pill"><strong>Model</strong> kernel objects</span></div>
            <div style="margin-top:8px"><span class="pill"><strong>Prove</strong> with tests</span></div>
            <div style="margin-top:8px"><span class="pill"><strong>Measure</strong> perf + latency</span></div>
          </div>
        </div>
      </aside>
    </div>

    <div class="footer">
      Generated 2026-02-06 20:53 UTC. Chapter 07. Static HTML. 
    </div>
  </div>

  <script src="../assets/tlpi_nav.js"></script>
  <script src="../assets/widgets.js"></script>
  <script src="../assets/ui.js"></script>
  <script>
    TLPIUI.initChapterPage({kind:"chapter", id:"ch07", n:7, subtitle:"Chapter 07 \u2014 Memory Allocation"});
    TLPIWidgets.mountKernelGraph("kg_ch07", {
      title: "Kernel mental model (chapter context)",
      subtitle: "Hover nodes to see what the object means. Highlighted nodes are most relevant to this chapter theme (mem). Click to pin a tooltip.",
      highlight: ["vmm", "vma", "page", "process", "pagecache"]
    });
  </script>
</body>
</html>
