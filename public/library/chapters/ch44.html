<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TLPI v2 — Chapter 44 — Pipes and FIFOs</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800;900&family=JetBrains+Mono:wght@300;400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css"/>
</head>
<body>
  <header class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="logo"></div>
        <div style="min-width:0">
          <h1>TLPI Interactive Library <span class="muted2">v2</span></h1>
          <div class="sub" id="subTitle">Chapter 44 — Pipes and FIFOs</div>
        </div>
      </div>
      <div class="actions">
        <span class="pill"><strong data-theme-badge>Dark</strong><span class="muted2">•</span><span class="muted">Theme</span></span>
        <button class="btn small" data-theme-toggle>Toggle</button>
        <a class="btn small ghost" href="../index.html">Index</a>
        <a class="btn small" data-prev disabled href="#" title="Previous (Ctrl/⌘+←)">Prev</a>
        <a class="btn small primary" data-next disabled href="#" title="Next (Ctrl/⌘+→)">Next</a>
      </div>
    </div>
    <div class="progress" id="scrollProgress"></div>
  </header>

  <div class="layout">
    <div class="shell">
      <aside class="sidebar">
        <div class="glass pad">
          <div class="section-title">Chapters</div>
          <input class="input" id="navSearch" placeholder="Search (press /)…"/>
          <div id="navList" class="navlist"></div>
        </div>

        <div class="glass pad" style="margin-top:12px">
          <div class="section-title">Chapter metadata</div>
          <div class="muted2 small" style="margin-top:8px">Reference: TLPI PDF page index <span class="mono">933</span> (0-based index 932).</div>
          <div class="muted2 small" style="margin-top:8px">Theme: <span class="pill"><strong>ipc</strong></span></div>
          <div style="margin-top:10px; display:flex; flex-wrap:wrap; gap:8px"><span class="pill"><strong>pipes</strong></span> <span class="pill"><strong>message queues</strong></span> <span class="pill"><strong>shared memory</strong></span> <span class="pill"><strong>semaphores</strong></span></div>
          <hr class="sep"/>
          <div class="muted2 small">Keyboard:</div>
          <div class="muted small" style="margin-top:6px">
            <span class="pill"><span class="mono">/</span> search</span>
            <span class="pill"><span class="mono">Ctrl/⌘ + ←/→</span> nav</span>
          </div>
        </div>
      </aside>

      <main>
        <div class="glass hero">
          <h2 style="background:linear-gradient(90deg, rgba(124,58,237,.92), rgba(6,182,212,.86)); -webkit-background-clip:text; background-clip:text; color:transparent">
            Chapter 44 — Pipes and FIFOs
          </h2>
          <div class="subtitle">
            <p>Interprocess communication is about moving data and coordination across process boundaries. Linux offers a spectrum: pipes (byte streams), message queues (framed messages), shared memory (fastest data path), and semaphores (coordination). Each comes with trade-offs in buffering, lifetime, naming, and failure semantics.</p><p>This guide is practical: when to pick which IPC, how to avoid deadlocks and leaks, and how to integrate IPC into an event loop (nonblocking + poll/epoll).</p>
          </div>
          <div class="callouts"><div class="callout good">
  <div class="k">Invariant</div>
  <div class="v">IPC objects have lifetimes; many outlive processes unless explicitly removed.</div>
</div><div class="callout warn">
  <div class="k">Gotcha</div>
  <div class="v">Blocking calls can deadlock. Prefer timeouts or nonblocking + poll/epoll.</div>
</div><div class="callout tip">
  <div class="k">Debugging</div>
  <div class="v">Inspect kernel objects (ipcs, /dev/shm, /dev/mqueue) and trace syscalls.</div>
</div></div>
        </div>

        <div class="glass pad-lg">
          <h3 class="section" data-toc="Mental model">Mental model</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            Internalize these bullets. If you can explain them clearly, you can debug most real-world incidents in this area.
          </div>
          <div class="prose">
            <ul><li>IPC is about data movement + coordination. Choose the primitive that matches semantics.</li><li>Streams (pipes) are great for linear flows; message queues for framed messages.</li><li>Shared memory gives throughput but requires careful synchronization and cleanup.</li><li>Blocking calls can deadlock; timeouts/nonblocking + epoll keep systems responsive.</li><li>Kernel objects can outlive processes: define ownership and deletion strategy.</li><li>Observe queue depth and latency; overload shows up there first.</li></ul>
          </div>
          <hr class="sep"/>
          <div class="muted2 small" style="margin-bottom:10px">Key terms & kernel objects</div>
          <table class="table">
  <thead><tr><th>Term / object</th><th>Meaning</th></tr></thead>
  <tbody><tr><td class='mono'>Pipe</td><td>Unidirectional byte stream between processes; supports backpressure via blocking/EAGAIN.</td></tr><tr><td class='mono'>FIFO</td><td>Named pipe in filesystem; opens connect readers/writers.</td></tr><tr><td class='mono'>Message queue</td><td>Kernel-managed queue of discrete messages; can be SysV or POSIX.</td></tr><tr><td class='mono'>Shared memory</td><td>Mapping shared between processes; fastest but requires explicit synchronization.</td></tr><tr><td class='mono'>Semaphore</td><td>Coordination primitive (counting); SysV or POSIX named/unnamed.</td></tr><tr><td class='mono'>Cleanup</td><td>IPC objects can outlive processes; define ownership and deletion strategy.</td></tr></tbody>
</table>
        </div>

        <div class="glass pad-lg">
  <h3 class="section" data-toc="Interactive labs">Interactive labs</h3>
  <div class="muted" style="margin-top:-4px; margin-bottom:12px">
    Poke the simulators to build intuition. These labs are educational models (not exact kernel behavior) but preserve key invariants.
  </div>
  <div id="kg_ch44"></div>
<div id="fd_ch44"></div>
</div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="API quick reference">API quick reference</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            A compact map of the APIs and their sharp edges. Always verify details with <span class="mono">man 2/3</span>.
          </div>
          <table class="table">
  <thead>
    <tr>
      <th>API</th>
      <th>Signature / shape</th>
      <th>Common errno</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr><td class='mono'>pipe</td><td class='mono'>int pipe(int pipefd[2]);</td><td class='mono muted2'>EMFILE, ENFILE</td><td>Unidirectional byte stream; beware of blocking semantics and SIGPIPE on write-end when read-end closed.</td></tr><tr><td class='mono'>pipe2</td><td class='mono'>int pipe2(int pipefd[2], int flags);</td><td class='mono muted2'>EMFILE, ENFILE, EINVAL</td><td>Create pipe with flags like O_CLOEXEC and O_NONBLOCK atomically.</td></tr><tr><td class='mono'>read</td><td class='mono'>ssize_t read(int fd, void *buf, size_t count);</td><td class='mono muted2'>EINTR, EAGAIN, EBADF, EFAULT</td><td>Short reads are normal (pipes/sockets/tty). Loop until done; handle EINTR and EAGAIN for nonblocking.</td></tr><tr><td class='mono'>write</td><td class='mono'>ssize_t write(int fd, const void *buf, size_t count);</td><td class='mono muted2'>EINTR, EAGAIN, EPIPE, EBADF, ENOSPC</td><td>Short writes are normal on pipes/sockets/nonblocking fds. SIGPIPE/EPIPE when peer is gone.</td></tr><tr><td class='mono'>fcntl</td><td class='mono'>int fcntl(int fd, int cmd, ... /* arg */ );</td><td class='mono muted2'>EBADF, EINVAL</td><td>Multiplexed control: FD_CLOEXEC, O_NONBLOCK, advisory locks (F_SETLK), signals (F_SETOWN).</td></tr>
  </tbody>
</table>
          <div class="muted2 small" style="margin-top:12px">
            Tip: always log enough context for errno to be actionable (inputs, flags, sizes).
          </div>
        </div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Edge cases & invariants">Edge cases & invariants</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            This is where production bugs live. Expand each panel and treat the bullets as test cases.
          </div>
          <details class="accordion">
  <summary>Choosing the right IPC</summary>
  <div class="content"><ul><li>Pipes/FIFOs are simplest for linear streams and shell-style composition.</li><li>Message queues give framing + priorities; good when you need discrete messages with bounded sizes.</li><li>Shared memory is fastest for bulk data but requires explicit synchronization (semaphores/mutexes) and careful lifetime management.</li><li>System V vs POSIX IPC differ in naming and cleanup behavior; choose based on your operational constraints.</li></ul></div>
</details><details class="accordion">
  <summary>Lifetime and cleanup (avoid leaks)</summary>
  <div class="content"><ul><li>Kernel objects outlive processes in some IPC systems (SysV queues/semaphores/shm). Leaks become operational incidents.</li><li>Always define ownership: who creates, who removes (IPC_RMID / unlink), and what happens on crash.</li><li>Design idempotent cleanup on startup (remove stale objects).</li><li>Use permissions and namespaces to isolate IPC objects between tenants/services.</li></ul></div>
</details><details class="accordion">
  <summary>Blocking, deadlocks, and backpressure</summary>
  <div class="content"><ul><li>Blocking IPC calls can deadlock if both sides wait. Use timeouts or nonblocking + poll/epoll integration.</li><li>Bound queues to enforce backpressure. Unbounded buffering moves the problem to RAM and causes collapse under load.</li><li>For shared memory, never rely on “it usually works”; use explicit barriers/atomics or mutexes for correctness.</li><li>Test failure modes: peer crash, partial writes, and restart sequences.</li></ul></div>
</details><details class="accordion">
  <summary>Debugging workflow</summary>
  <div class="content"><ul><li>For pipes/sockets, strace and /proc/&lt;pid&gt;/fd are your first line of truth.</li><li>For SysV IPC, use ipcs/ipcrm tools to inspect and clean up.</li><li>For POSIX mqueue/shm, check /dev/mqueue and /dev/shm; naming and permissions matter.</li><li>Measure queue depths and latency. Hidden buffering is a frequent cause of tail latency spikes.</li></ul></div>
</details>
        </div>

        <div class="glass pad-lg">
  <div style="display:flex; align-items:center; justify-content:space-between; gap:10px">
    <h3 class="section" data-toc="Code patterns">Code patterns (C / POSIX) </h3>
    <button class="btn small" data-copy="#code_ch44">Copy</button>
  </div>
  <div class="muted" style="margin-top:-4px; margin-bottom:12px">
    These are compact patterns to internalize. Treat them as starting points: add proper error handling, timeouts, and logging.
  </div>
  <pre id="code_ch44"><code class="mono">// Pipe IPC with framing (length prefix)
uint32_t len = htonl(payload_len);
write_all(wfd, &amp;len, sizeof(len));
write_all(wfd, payload, payload_len);

// receiver:
uint32_t n;
read_all(rfd, &amp;n, sizeof(n));
n = ntohl(n);
read_all(rfd, buf, n);</code></pre>
</div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Production checklist">Production checklist</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            If you are shipping code in this area, try to satisfy each checklist item explicitly.
          </div>
          <div class="prose">
            <ul><li>Pick IPC type based on semantics: stream vs message vs shared memory.</li><li>Define lifetime/cleanup and test crash recovery paths.</li><li>Bound queues and buffer sizes to enforce backpressure.</li><li>Integrate with poll/epoll and prefer nonblocking I/O for responsiveness.</li><li>Instrument latency and queue depth; these are leading indicators of overload.</li></ul>
          </div>
        </div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Exercises">Exercises</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            Hands-on tasks to make the chapter “stick”. These are intentionally practical and debugging-heavy.
          </div>
          <div class="prose">
            <ul><li>Build a parent/child protocol over pipes: framed messages with length prefix + CRC; handle partial I/O.</li><li>Build shared-memory ring buffer with a semaphore for producer/consumer coordination.</li><li>Compare SysV and POSIX message queues for priority + notification behavior.</li></ul>
          </div>
        </div>

        <div class="glass pad-lg" style="margin-top:12px">
          <h3 class="section" data-toc="Quiz">Quiz</h3>
          <div class="muted" style="margin-top:-4px; margin-bottom:12px">
            Click an option to check your understanding. The explanation points to the underlying invariant.
          </div>
          <div class="quiz"><div class="q" data-quiz data-answer="1" data-explain="Man pages and experiments (strace) are the fastest path to correct mental models.">
  <div class="qp">Q1. What is the most reliable way to learn syscall behavior?</div>
  <div class="opts"><div class="opt" data-opt="0">
  <div class="dot"></div>
  <div><div style="font-weight:750">Guessing</div></div>
</div><div class="opt" data-opt="1">
  <div class="dot"></div>
  <div><div style="font-weight:750">Reading man 2/3 + experimenting</div></div>
</div><div class="opt" data-opt="2">
  <div class="dot"></div>
  <div><div style="font-weight:750">Copying random code</div></div>
</div><div class="opt" data-opt="3">
  <div class="dot"></div>
  <div><div style="font-weight:750">Avoiding errors</div></div>
</div></div>
  <div class="feedback muted2 small"></div>
</div><div class="q" data-quiz data-answer="1" data-explain="errno is thread-local and only meaningful immediately after a failure.">
  <div class="qp">Q2. Which is true about errno?</div>
  <div class="opts"><div class="opt" data-opt="0">
  <div class="dot"></div>
  <div><div style="font-weight:750">It is global and never changes</div></div>
</div><div class="opt" data-opt="1">
  <div class="dot"></div>
  <div><div style="font-weight:750">It is thread-local and should be read immediately</div></div>
</div><div class="opt" data-opt="2">
  <div class="dot"></div>
  <div><div style="font-weight:750">It is only for networking</div></div>
</div><div class="opt" data-opt="3">
  <div class="dot"></div>
  <div><div style="font-weight:750">It is reset to 0 after each call</div></div>
</div></div>
  <div class="feedback muted2 small"></div>
</div><div class="q" data-quiz data-answer="1" data-explain="A minimal reproduction + strace quickly reveals the failing boundary and errno.">
  <div class="qp">Q3. A good debugging approach is:</div>
  <div class="opts"><div class="opt" data-opt="0">
  <div class="dot"></div>
  <div><div style="font-weight:750">Start with perf</div></div>
</div><div class="opt" data-opt="1">
  <div class="dot"></div>
  <div><div style="font-weight:750">Start with strace and minimal reproduction</div></div>
</div><div class="opt" data-opt="2">
  <div class="dot"></div>
  <div><div style="font-weight:750">Start with rewriting everything</div></div>
</div><div class="opt" data-opt="3">
  <div class="dot"></div>
  <div><div style="font-weight:750">Ignore symptoms</div></div>
</div></div>
  <div class="feedback muted2 small"></div>
</div></div>
        </div>

        <div class="glass pad" style="margin-top:12px">
          <div class="muted2 small">
            Disclaimer: This companion is original educational content and does not reproduce TLPI’s text or figures.
            Always verify details with man pages and your target kernel/libc versions.
          </div>
        </div>
      </main>

      <aside class="righttoc">
        <div class="glass pad">
          <div class="section-title">On this page</div>
          <div id="toc" class="toc"></div>
        </div>

        <div class="glass pad" style="margin-top:12px">
          <div class="section-title">Read like an operator</div>
          <div class="muted small" style="line-height:1.7">
            <div><span class="pill"><strong>Observe</strong> strace / /proc / ss</span></div>
            <div style="margin-top:8px"><span class="pill"><strong>Model</strong> kernel objects</span></div>
            <div style="margin-top:8px"><span class="pill"><strong>Prove</strong> with tests</span></div>
            <div style="margin-top:8px"><span class="pill"><strong>Measure</strong> perf + latency</span></div>
          </div>
        </div>
      </aside>
    </div>

    <div class="footer">
      Generated 2026-02-06 20:53 UTC. Chapter 44. Static HTML. 
    </div>
  </div>

  <script src="../assets/tlpi_nav.js"></script>
  <script src="../assets/widgets.js"></script>
  <script src="../assets/ui.js"></script>
  <script>
    TLPIUI.initChapterPage({kind:"chapter", id:"ch44", n:44, subtitle:"Chapter 44 \u2014 Pipes and FIFOs"});
    TLPIWidgets.mountKernelGraph("kg_ch44", {
      title: "Kernel mental model (chapter context)",
      subtitle: "Hover nodes to see what the object means. Highlighted nodes are most relevant to this chapter theme (ipc). Click to pin a tooltip.",
      highlight: ["pipe", "file", "process", "signal", "fdtable", "epoll", "vmm"]
    });
TLPIWidgets.mountFDLab("fd_ch44", {});
  </script>
</body>
</html>
